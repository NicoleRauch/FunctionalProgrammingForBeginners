%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Funktional, das ist doch nur für Esoteriker?!}

\onslide+<2>
\begin{itemize}
\item ABN AMRO Amsterdam \textcolor{gray}{\textit{Risikoanalysen Investmentbanking}}
\item AT\&T \textcolor{gray}{\textit{Netzwerksicherheit: Verarbeitung von Internet-Missbrauchsmeldungen}}
\item Bank of America Merril Lynch \\ \textcolor{gray}{\textit{Backend: Laden \& Transformieren von Daten}}
\item Barclays Capital Quantitative Analytics Group \\ \textcolor{gray}{\textit{Mathem. Modellierung von Derivaten}}
\item Bluespec, Inc. \textcolor{gray}{\textit{Modellierung \& Verifikation integrierter Schaltkreise}}
\item Credit Suisse \textcolor{gray}{\textit{Prüfen und Bearbeiten von Spreadsheets}}
\item Deutsche Bank Equity Proprietary Trading, Directional Credit Trading \textcolor{gray}{\textit{Gesamte Software-Infrastruktur}}
\item Facebook \textcolor{gray}{\textit{Interne Tools}}
\item Factis Research, Freiburg \textcolor{gray}{\textit{Mobil-Lösungen (Backend)}}
\item fortytools gmbh \textcolor{gray}{\textit{Webbasierte Produktivitätstools - REST-Backend}}
\item Functor AB, Stockholm \textcolor{gray}{\textit{Statische Codeanalyse}}
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Funktional, das ist doch nur für Esoteriker?!}
\begin{itemize}
\item Galois, Inc \textcolor{gray}{\textit{Security, Informationssicherheit, Kryptographie}}
\item Google \textcolor{gray}{\textit{Interne Projekte}}
\item iPwn Studios \textcolor{gray}{\textit{Spieleengine}}
\item JanRain \textcolor{gray}{\textit{Netzwerk- und Web-Software}}
\item MITRE \textcolor{gray}{\textit{Analyse kryptographischer Protokolle}}
\item New York Times \textcolor{gray}{\textit{Bildverarbeitung für die New York Fashion Week}}
\item NVIDIA \textcolor{gray}{\textit{In-House Tools}}
\item Parallel Scientific \textcolor{gray}{\textit{Hochskalierbares Cluster-Verwaltungssystem}}
\item Sankel Software \textcolor{gray}{\textit{CAD/CAM, Spiele, Computeranimation}}
\item Silk, Amsterdam \textcolor{gray}{\textit{Filtern und Visualisieren großer Datenmengen}}
\item Skedge Me \textcolor{gray}{\textit{Online-Terminvereinbarungen}}
\item Standard Chartered \textcolor{gray}{\textit{Bankensoftware}}
\item Starling Software, Tokio \textcolor{gray}{\textit{Automatisiertes Optionshandelssystem}}
\item Suite Solutions \textcolor{gray}{\textit{Verwaltung technischer Dokumentationen}}
\end{itemize}
{\small (Quelle: \url{http://www.haskell.org/haskellwiki/Haskell_in_industry})}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Bekannte funktionale Sprachen}
\begin{tikzpicture}
\draw (1.5, 1.5) node {Lisp};
\draw (1.5, 5.5) node {Scheme};
\draw (4.2, 4.9) node {ML};
\draw (10.5, 3.5) node {OCaml};
\draw (1.5, 3.5) node {Miranda};
\draw (7.3, 4.6) node {F\#};
\draw (6.3, 5.6) node {Erlang};
\draw (9.3, 5.3) node {Clojure};
\draw (4.5, 1.5) node {Scala};

\onslide+<1-2>
\draw (5.5, 3.0) node {Haskell};
\onslide+<2>
\draw (8.5, 1.3) node {(JavaScript)};
\onslide+<3>
\draw (5.5, 3.0) node {\color{red}Haskell};
\draw (8.5, 1.3) node {\color{red}(JavaScript)};
\end{tikzpicture}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Was ist denn daran so besonders?}

\onslide+<2->
\begin{center}
\Large
Funktionen sind \glqq{}first order citizens\grqq{}
\end{center}

\vspace{2em}

\onslide+<3->
\begin{center}
Mit Funktionen kann man dasselbe machen wie mit Strings oder Zahlen
\end{center}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Funktionen können Variablen zugewiesen werden}
\onslide+<2->
JavaScript:
\begin{lstlisting}{JavaScript}
function times(x, y) { return x * y; }

var timesVar = times;
    
timesVar(3, 5) === 15;
\end{lstlisting}

\onslide+<3->
Haskell:
\begin{lstlisting}{Haskell}
times x y = x * y

timesVar = times

timesVar 3 5 == 15
\end{lstlisting}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Funktionen können als Funktionsparameter übergeben werden}
\onslide+<2->
JavaScript:
\begin{lstlisting}{javascript}
function wendeAn(func, arg) { return func(arg); }

function times3(y) { return 3 * y; };

wendeAn(times3, 5) === 15;
\end{lstlisting}

\onslide+<3->
Haskell:
\begin{lstlisting}{Haskell}
wendeAn func arg = func arg

wendeAn (\ x -> 3 * x) 5 == 15
\end{lstlisting}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Funktionen können von Funktionen zurückgegeben werden}
\onslide+<2->
JavaScript:
\begin{lstlisting}{javascript}
function times(x) { return function (y) { return x * y; }; }

times(3)(5) === 15;
\end{lstlisting}

\onslide+<3->
Haskell:
\begin{lstlisting}{Haskell}
times x = (\y -> x * y)

times 3 5 == 15
\end{lstlisting}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Komisch, oder?}
JavaScript: Zwei verschiedene Aufrufe
\begin{lstlisting}{javascript}
function times(x, y) { return x * y; }
times(3, 5) === 15;

function times(x) { return function (y) { return x * y; }; }
times(3)(5) === 15;
\end{lstlisting}
~\\
Haskell: Zweimal derselbe Aufruf
\begin{lstlisting}{Haskell}
times x y = x * y
times 3 5 == 15

times x = (\y -> x * y)
times 3 5 == 15
\end{lstlisting}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Currying! (oder auch Schönfinkeln)}
\onslide+<2->
In echten funktionalen Sprachen schreiben wir:
\begin{lstlisting}{Haskell}
times x y = x * y
\end{lstlisting}

und eigentlich passiert Folgendes:
\begin{lstlisting}{Haskell}
times x = (\y -> x * y)
\end{lstlisting}

\onslide+<3->
Denn: Funktionen haben immer nur ein Argument
\vfill
\onslide+<4->
Nutzen: Partielle Evaluierung:
\begin{lstlisting}{Haskell}
times x y = x * y

times3 = times 3

times3 5 == 15
\end{lstlisting}


\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\begin{frame}[fragile]{Closures}
%
%\onslide+<2->
%\begin{lstlisting}{javascript}
%    function neueClosure(zahl) {
%      var zaehler = zahl;
%      return function (inkrement) {
%        zaehler += inkrement;
%        return zaehler;
%      }
%    }
%
%    var closure1 = neueClosure(10);
%    var closure2 = neueClosure(20);
%\end{lstlisting}
%\onslide+<3->
%\begin{lstlisting}{javascript}
%    closure1(5) === 15;
%\end{lstlisting}
%\onslide+<4->
%\begin{lstlisting}{javascript}
%    closure2(5) === 25;
%\end{lstlisting}
%\onslide+<5->
%\begin{lstlisting}{javascript}
%    closure1(5) === 20;
%\end{lstlisting}
%\onslide+<6->
%\begin{lstlisting}{javascript}
%    closure2(5) === 30;
%\end{lstlisting}
%
%\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Und wenn ich kein Argument haben will?}
\begin{itemize}
\item In echten funktionalen Sprachen bekommen Funktionen immer ein Argument!
\item Was ist, wenn ich nichts habe?!
\onslide+<2->
\item \texttt{Unit} to the rescue!
\onslide+<3->
\item \texttt{Unit} ist ein Typ mit nur einem Element
\onslide+<4->
\item Das Element heißt in Haskell \texttt{()}
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Wichtige Bibliotheksfunktionen: filter}
\begin{itemize}
\item filter oder auch select
\onslide+<2->
\item Nimmt eine Collection und eine Funktion
\item Liefert diejenigen Elemente der Collection, für die die Funktion \texttt{true} ergibt
\end{itemize}

\onslide+<3->
JavaScript: (mit freundlicher Unterstützung der lodash-Bibliothek)
\begin{lstlisting}{javascript}
var result = _.filter([1, 2, 3, 4], function (x) { return x % 2 === 0; });
    
Ergebnis: [2, 4];
\end{lstlisting}
\onslide+<4->
Haskell:
\begin{lstlisting}{Haskell}
filter (\x -> x `mod` 2 == 0) [1,2,3,4] == [2,4]
\end{lstlisting}

\end{frame}

% find oder detect

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Wichtige Bibliotheksfunktionen: map}
\begin{itemize}
\item map oder auch collect
\onslide+<2->
\item Nimmt eine Collection und eine Funktion
\item Liefert eine Collection, in der die Funktion auf jedes Element der ursprünglichen Collection angewandt wurde
\end{itemize}

\onslide+<3->
JavaScript:
\begin{lstlisting}{javascript}
var result = _.map( [1, 2, 3, 4], function (x) { return x + 5; } );

Ergebnis: [6, 7, 8, 9];
\end{lstlisting}
\onslide+<4->
Haskell:
\begin{lstlisting}{Haskell}
map (\x -> x + 5) [1,2,3,4] == [6,7,8,9]
\end{lstlisting}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Wichtige Bibliotheksfunktionen: fold}
\begin{itemize}
\item fold oder auch reduce oder inject
\onslide+<2->
\item Nimmt eine Collection und eine Funktion
\item Verbindet zwei Elemente der Collection mit Hilfe der Funktion zu einem Element
\item Verbindet das Ergebnis mit dem nächsten Element der Collection zu einem Element
\item Setzt dies für alle Elemente der Collection fort, bis nur noch ein Element übrigbleibt
\end{itemize}

\onslide+<3->
JavaScript: (mit oder ohne initiales Element)
\begin{lstlisting}{javascript}
var result = _.foldl( [2, 3, 4, 5], function (x, y) { return x * y; } );
var result = _.foldl( [2, 3, 4, 5], function (x, y) { return x * y; }, 1 );
result === 120;
\end{lstlisting}
\onslide+<4->
Haskell (nur mit initialem Element):
\begin{lstlisting}{Haskell}
foldl	(*) 1 [2,3,4,5] == 120
\end{lstlisting}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Typinferenz}
\begin{itemize}
\item Haskell: starkes statisches Typsystem
\item Leichtgewichtige Verwendung dank Typinferenz
\item Herleitung des allgemeinst möglichen Typs
\end{itemize}

\onslide+<2->
\begin{lstlisting}{Haskell}
foldl :: (a -> b -> a) -> a -> [b] -> a
(*) :: Num a => a -> a -> a

foldl	(*) 1 [2,3,4,5]
\end{lstlisting}

\vfill

\onslide+<3->
Compilerfehler für:
\begin{lstlisting}{Haskell}
foldl	(*) "x" [2,3,4,5]

No instance for (Num [Char]) arising from a use of `*'
Possible fix: add an instance declaration for (Num [Char])
\end{lstlisting}

\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Eine einfache Berechnung}

\[
summe = \sum_{i=1}^{10}i^2
\]

\vspace{5em}

\onslide+<2->
\begin{lstlisting}{java}
int summe = 0;
for(int i = 1; i <= 10; i++) {
  summe = summe + i * i;
}
\end{lstlisting}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Exkurs: Clean Code}
Single Responsibility Principle
\\[2em]

\onslide+<2->
Wie viele Verantwortlichkeiten hat dieser Code?
\begin{lstlisting}{java}
int summe = 0;
for(int i = 1; i <= 10; i++) {
  summe = summe + i * i;
}
\end{lstlisting}

\onslide+<3->
\begin{itemize}
\item Erzeugen der Zahlenfolge von 1 bis 10
\onslide+<4->
\item Quadrieren einer Zahl
\onslide+<5->
\item Berechnen der Quadratzahl jeder Zahl in der Folge
\onslide+<6->
\item Addieren zweier Zahlen
\onslide+<7->
\item Aufsummieren der Quadratzahlen
\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Trennen der Verantwortlichkeiten}
\begin{itemize}
\item Erzeugen der Zahlenfolge von 1 bis 10
\onslide+<2->
\begin{lstlisting}{javascript}
var zahlenfolge = _.range(1, 11);
\end{lstlisting}
\onslide+<1->
\item Quadrieren einer Zahl
\onslide+<3->
\begin{lstlisting}{javascript}
var quadriere = function (i) { return i * i; };
\end{lstlisting}
\onslide+<1->
\item Berechnen der Quadratzahl jeder Zahl in der Folge
\onslide+<4->
\begin{lstlisting}{javascript}
var quadrierteFolge = _.map(zahlenfolge, quadriere)
\end{lstlisting}
\onslide+<1->
\item Addieren zweier Zahlen
\onslide+<5->
\begin{lstlisting}{javascript}
var addiere = function (summe, summand) { return summe + summand; };
\end{lstlisting}
\onslide+<1->
\item Aufsummieren der Quadratzahlen
\onslide+<6->
\begin{lstlisting}{javascript}
var summe = _.reduce(quadrierteFolge, addiere);
\end{lstlisting}
\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Zusammensetzen der Komponenten}
JavaScript:
\begin{lstlisting}{javascript}
var quadriere = function (i) { return i * i; };
var addiere = function (summe, summand) { return summe + summand; };
\end{lstlisting}

\begin{lstlisting}{javascript}
_.reduce(_.map(_.range(1, 11), quadriere), addiere) === 385;
\end{lstlisting}

\onslide+<2->
oder

\begin{lstlisting}{javascript}
_(1).range(11).map(quadriere).reduce(addiere) === 385;
\end{lstlisting}

\onslide+<3->
Haskell:
\begin{lstlisting}{Haskell}
foldl	(+) 0 (map (\x -> x*x) [1..10]) == 385
\end{lstlisting}
oder
\begin{lstlisting}{Haskell}
(>.>) x f = f x
[1..10] >.> map (\x -> x*x) >.> foldl (+) 0 == 385
\end{lstlisting}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Uff!}

\begin{center}
\Large
OK, alle einmal tief durchatmen :-)
\end{center}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Pattern Matching}
Fibonacci-Funktion \glqq naiv\grqq{}:
\begin{lstlisting}{Haskell}
fib x = if x < 2 then x else fib (x-1) + fib (x-2)
\end{lstlisting}

\onslide+<2->
\vfill
Fibonacci-Funktion mit Pattern Matching:
\begin{lstlisting}{Haskell}
fib 0 = 0
fib 1 = 1
fib x = fib (x-1) + fib (x-2)
\end{lstlisting}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Algebraische Datentypen}
Binärbaum:
\begin{lstlisting}{Haskell}
data Tree =
       Node Tree Tree
     | Leaf Int
\end{lstlisting}

\onslide+<2->
\begin{lstlisting}{Haskell}
myTree = Node (Node (Leaf 4) (Node (Leaf 7) (Leaf 1))) (Leaf 3)
\end{lstlisting}

\onslide+<3->
Summenfunktion:
\onslide+<4->
\begin{lstlisting}{Haskell}
treeSum	(Leaf x) = x
\end{lstlisting}
\onslide+<5->
\vspace{-1.1em}
\begin{lstlisting}{Haskell}
treeSum (Node m n) = treeSum m + treeSum n
\end{lstlisting}
\onslide+<6->
\begin{lstlisting}{Haskell}
treeSum myTree == 15
\end{lstlisting}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Fazit}
\begin{itemize}
\item Funktionale Programmierung ist verbreiteter als man denkt
\item Java 8 hat funktionale Neuerungen
\item Viele Sprachen bringen funktionale Aspekte oder Zusatzmodule mit
\end{itemize}

\vfill

\onslide+<2->
Referenzen:

\begin{itemize}
\item Funktionale JS-Bibliothek: \url{http://lodash.com}
\item Haskell: \url{http://www.haskell.org}
\end{itemize}

\end{frame}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{
\usebackgroundtemplate{\includegraphics[width=\paperwidth,height=\paperheight]{background-slide.png}}
\begin{frame}{}

        ~\\[4em]
        Code \& Folien auf GitHub:
        \begin{center}
                \url{https://github.com/NicoleRauch/FunctionalProgrammingForBeginners}
        \end{center}

        ~\\[1em]
        \begin{block}{Nicole Rauch}
        \begin{description}[Twitterxx]
                \item[E-Mail]  \href{mailto:nicole.rauch@msg-gillardon.de}{\texttt{nicole.rauch@msg-gillardon.de}}
                \item[Twitter] \href{http://twitter.com/NicoleRauch}{\texttt{@NicoleRauch}}
        \end{description}
        \end{block}
\end{frame}
}
